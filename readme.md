# Electric Vehicle Charging Optimization System

This project implements a complete system for managing and optimizing the charging of electric vehicles at charging stations, using different algorithmic approaches:

1. **Constructive heuristic with adaptive improvements** - Custom algorithm with local search
2. **Reinforcement Learning (RL)** - Using Deep Q-Networks (DQN)
3. **Mixed Integer Linear Programming (MILP)** - For solution refinement

## Project Structure

```
.
├── checkpoints/           # Checkpoints for RL models
├── cluster_results/       # Clustering analysis results
│   └── representative_files/  # Representative instances
├── data/                  # Test instances
├── heuristic_results/     # Results generated by the heuristic algorithm
├── hyperparameter_analysis/ # Hyperparameter analysis
├── hyperparameter_results/ # Hyperparameter search results 
├── plots/                 # Plots generated by the system
├── results/               # Results generated by RL and MILP
├── clusters.py            # Instance clustering analysis
├── ev_scheduler_generalized_model.h5 # Pre-trained DQN model
├── heuristic.py           # Constructive heuristic implementation
├── hyperparameter_tuning.py # Hyperparameter search and optimization
├── k_means_heuristic.py   # Parameter selection based on clustering
├── model131.py            # RL and MILP model implementation
├── plot_tables.py         # Table generation for reports
├── plots_heuristics.py    # Visualization of heuristic results
├── plots_milp.py          # Visualization of MILP/RL results
├── pseudocodigo_heuristica.md # Heuristic algorithm documentation
├── results.py             # Comparative analysis of results
```

## System Features

- **Generalization**: The system can adapt to different types of instances with variability in number of EVs, parking spots, chargers, and price patterns.
- **Multi-objective optimization**: Minimizes charging cost while maximizing energy demand satisfaction.
- **Adaptive parameter selection**: Uses clustering to automatically select the best hyperparameters based on instance characteristics.
- **Advanced visualization**: Multiple visualization tools to evaluate solution quality.
- **Capacity analysis**: Tools to simulate and analyze different parking capacity scenarios.

## Main Components

### 1. Heuristic Algorithm (`heuristic.py`)

The improved constructive heuristic implements an initial solution followed by an improvement phase using local search. It includes:

- Initial construction with intelligent prioritization
- Use of simulated annealing for solution space exploration
- Adaptive perturbation strategies
- Consolidation of charging sessions

### 2. Reinforcement Learning (`model131.py`)

The RL component implements a DQN agent with the following features:

- Generalized states that capture the relevant characteristics of the problem
- Discretized actions to handle complex action spaces
- System-specific experience memory for knowledge transfer
- Error protections for production robustness

### 3. MILP Refinement (`model131.py`)

The MILP component implements an exact model for solution refinement:

- Decision variables for charger assignment and power
- Capacity constraints for slots, chargers, and transformer
- Violation handling through slack variables
- Objective function that minimizes cost and penalizes unsatisfied energy

### 4. Clustering Analysis (`clusters.py`)

The system uses clustering to analyze and classify instances:

- Automatic extraction of relevant features
- K-means to group similar instances
- Selection of representative instances
- Feature importance analysis

### 5. Hyperparameter Optimization (`hyperparameter_tuning.py`)

The system includes a complete module for hyperparameter optimization:

- Grid search and random search
- Parameter sensitivity analysis
- 3D visualization of hyperparameter spaces
- Parallelization for process acceleration

## System Requirements

- Python 3.8+
- TensorFlow 2.5+
- PuLP for MILP
- Scikit-learn for clustering analysis
- Pandas and NumPy for data manipulation
- Matplotlib and Seaborn for visualizations

## System Usage

### 1. Data Preparation

Place your instances in JSON format in the `data/` directory with the following structure:

```json
{
  "energy_prices": [{"time": float, "price": float}, ...],
  "arrivals": [
    {
      "id": int,
      "arrival_time": float,
      "departure_time": float,
      "required_energy": float
    },
    ...
  ],
  "parking_config": {
    "n_spots": int,
    "chargers": [{"charger_id": int, "power": float}, ...],
    "transformer_limit": float
  }
}
```

## Running the Heuristic Algorithm (heuristic.py)

The heuristic algorithm (`heuristic.py`) can be run independently to test its performance on specific instances or to process multiple instances in batch.

### Execution Options

```bash
# To get help on available commands
python heuristic.py

# For a single instance
python heuristic.py data/test_system_1.json [output_file]

# To process all files in a directory
python heuristic.py --all [data_directory] [output_directory]
```

#### Processing a Single Instance

When run for a single instance, the script accepts two parameters:

1. **json_file** (required): Path to the JSON file with system data
   - Example: `python heuristic.py data/test_system_1.json`

2. **output_file** (optional): Path where to save the results
   - If not specified, it is saved in `heuristic_results/[instance_name]_result.json`
   - Example: `python heuristic.py data/test_system_1.json my_solution.json`

**Process and outputs:**
- Automatically loads the optimal hyperparameter configuration based on clustering
- Runs the constructive heuristic with adaptive improvements
- Displays solution statistics (cost, energy, satisfaction)
- Generates three plots:
  - `[name]_charge.png`: Vehicle charging profile
  - `[name]_parking.png`: Parking spot assignment
  - `[name]_cost_evolution.png`: Cost evolution during optimization
- Saves the result in JSON format with:
  - Detailed schedule by vehicle
  - Solution statistics
  - Details of unsatisfied vehicles
  - Execution time

#### Batch Processing

With the `--all` option, the script accepts two additional parameters:

1. **data_directory** (optional): Directory containing the JSON files
   - Default value: `./data`
   - Example: `python heuristic.py --all my_instances/`

2. **output_directory** (optional): Directory where to save the results
   - Default value: `./results`
   - Example: `python heuristic.py --all data/ my_results/`

**Process and outputs:**
- Processes all JSON files found in the directory
- Generates the same individual results as the single instance mode
- Creates a CSV file with comparative results (`comparative_results.csv`)
- Displays a summary table in the console with key metrics

### Heuristic Algorithm Features

The algorithm implements:
- Initial construction with prioritization based on charging urgency
- Priority continuity to maintain uninterrupted charging sessions
- Improvement phase with multiple perturbation strategies:
  - Interval perturbation: modifies assignments in specific periods
  - Vehicle perturbation: removes and reassigns selected vehicles
  - Hybrid perturbation: combines both approaches
  - Session perturbation: focused on continuous charging sessions
- Consolidation that fills "gaps" in charging sessions
- Automatic hyperparameter selection based on clustering

## Running the Main Program (model131.py)

The main file `model131.py` integrates all system components and offers different operation modes. To run it:

```bash
python model131.py
```

### Operation Modes and Options

When running the program, a menu with the following modes will be presented:

```
Electric Vehicle Charging Optimization System
--------------------------------------------------------

Available modes:
1. Generalized training (create model for all systems)
2. Solution for a specific instance (using generalized model)
3. Check training progress and checkpoints
4. Process ALL instances automatically (RL and MILP)
5. Visualize MILP solution from file
6. Generate comparative results table (JSON only)

Select mode (1-6): 
```

#### Mode 1: Generalized Training

This mode trains the reinforcement learning model using all available instances.

**Requested options:**
- **Number of episodes per system**: Recommended between 30-50. Higher number = better solution quality but more training time.
- **Checkpoint saving frequency**: Typically 5-10. Determines how often progress is saved.
- **Resume from last checkpoint**: [y/n] Allows continuing a previous training from where it was interrupted.

**Example:**
```
Number of episodes per system (recommended: 30-50): 30
Save checkpoint every how many episodes (recommended: 5): 5
Do you want to resume from the last checkpoint? (y/n): n
```

#### Mode 2: Solution for a Specific Instance

Solves a specific instance using the generalized model and MILP.

**Requested options:**
- **JSON filename**: Accepts three formats:
  - Full path: `./data/test_system_1.json`
  - Name only: `test_system_1.json`
  - Number only: `1` (will look for `test_system_1.json`)

**Example:**
```
Enter the JSON filename (e.g.: test_system_1.json): 5
```

The system will generate:
1. RL solution (results_rl_instance_X.json)
2. Refined MILP solution (results_milp_instance_X.json)

#### Mode 3: Check Training Progress

Shows information about available checkpoints and training progress.

**Additional options:**
- **Visualize progress graphically**: [y/n] Generates training progress graphs.
- **Delete old checkpoints**: [y/n] Option to free space by keeping only the most recent checkpoints.

**Example:**
```
Do you want to visualize the progress graphically? (y/n): y
Do you want to delete old checkpoints to free up space? (y/n): n
```

#### Mode 4: Process ALL Instances Automatically

Batch processes all available instances in the data directory.

**No additional options** - The system:
- Checks which instances are already processed
- Applies adaptive time limits based on the size of each instance
- Saves results in the `results/` directory

#### Mode 5: Visualize MILP Solution from File

Generates visualizations from a previously calculated solution.

**Requested options:**
- **Instance number**: Numerical identifier of the instance to visualize.

**Example:**
```
Enter the instance number (e.g.: 10): 3
```

Generates two plots:
- Vehicle charging profiles
- Parking spot assignment over time

#### Mode 6: Infeasibility Analysis

Generates a comparative table focused on detecting infeasible instances.

**No additional options** - The system analyzes all available results and generates:
- CSV/Excel table with infeasibility analysis
- Statistics on vehicles with zero energy
- Demand satisfaction metrics


### Typical Workflow Example

1. **Initial training** (Mode 1):
   ```bash
   python model131.py
   # Select mode 1
   # Specify 30 episodes per system
   # Save checkpoint every 5 episodes
   ```

2. **Process all instances** (Mode 4):
   ```bash
   python model131.py
   # Select mode 4
   ```

3. **Analyze results** (Mode 6):
   ```bash
   python model131.py
   # Select mode 6
   ```

4. **Visualize specific solution** (Mode 5):
   ```bash
   python model131.py
   # Select mode 5
   # Enter instance number (e.g.: 10)
   ```

### Hardware Requirements

The system is optimized to run on equipment with the following characteristics:

- Multi-core CPU (4+ cores recommended)
- 8GB+ RAM (16GB+ recommended for large instances)
- GPU optional but recommended for accelerated training

For very large instances (500+ vehicles), batch processing is recommended (automatically implemented).

### 2. Using the Heuristic Algorithm Directly

To compare results between different approaches, you can run the heuristic first:

```bash
# Process a specific instance
python heuristic.py data/test_system_1.json

# Process all instances for comparison
python heuristic.py --all data/ heuristic_results/
```

For complex problems with many vehicles (>200), the heuristic can offer quick and good quality solutions.

### 3. RL Model Training

```bash
python model131.py
# Select mode 1 for generalized training
```

### 4. Hyperparameter Optimization

```bash
python hyperparameter_tuning.py
```

### 5. Solution for a Specific Instance

```bash
python model131.py
# Select mode 2 to solve a specific instance
```

### 6. Batch Processing

```bash
python model131.py
# Select mode 4 to process all instances
```

### 7. Generation of Comparative Tables

```bash
python results.py
```

### 8. Comparison between Heuristic and RL+MILP

To compare solutions between the heuristic and the combined RL+MILP approach:

```bash
# Generate comparative visualization
python plot_comparative.py heuristic_results/test_system_1_result.json results/results_milp_instance_1.json
```

This will generate a comparison plot showing the charging profiles and differences in slot utilization.

## Running Analysis and Visualization Tools

### Running plots_milp.py

The `plots_milp.py` file implements a complete set of tools to analyze results and evaluate charging infrastructure performance. To run it:

```bash
python plots_milp.py
```

When starting the program, an interactive menu will be presented with the following options:

```
=== ANALYSIS MENU ===
1. Cost comparison (RL vs MILP)
2. Parking congestion analysis
3. Rejected vehicles analysis
4. Transformer usage analysis
5. Optimal capacity simulation
6. Exit
```

For each option, you can choose to analyze:
- All instances
- A specific instance
- The 3 most congested instances

#### 1. Cost comparison (RL vs MILP)

Generates comparative graphs between RL and MILP solutions, showing:
- Total costs
- Improvement percentage
- Delivered energy
- Percentage of EVs served
- Execution times

Results are saved as `plots/cost_comparison.png` and `plots/time_comparison.png`.

#### 2. Parking congestion analysis

Visualizes how parking demand varies over time:
- Present vehicles vs. available capacity
- Utilization percentage
- Vehicles without space in each interval
- Identification of periods with excess demand

Results are saved as `plots/parking_congestion.png`.

#### 3. Rejected vehicles analysis

Analyzes vehicles that cannot be served due to lack of space:
- Distribution of rejections by time of day
- Characteristics of rejected vehicles
- Congestion and rejections over time
- Calculation of opportunity cost

Results are saved as `plots/rejected_vehicles_analysis.png`.

#### 4. Transformer usage analysis

Examines transformer utilization over time:
- Comparison between RL and MILP solutions
- Times of highest energy demand
- Percentage of time near the limit
- Efficiency in the use of available power

Results are saved as `plots/transformer_usage.png`.

#### 5. Optimal capacity simulation

Simulates different capacity configurations to find the optimal point:
- Rejection rate vs. capacity
- ROI and revenue by capacity
- Identification of optimal economic capacity
- Specific sizing recommendations

Results are saved as `plots/capacity_simulation.png`.

### Running plots_heuristics.py

The `plots_heuristics.py` file provides tools to analyze the impact of hyperparameters on the performance of the heuristic algorithm. To run it:

```bash
python plots_heuristics.py
```

This program automatically analyzes the hyperparameter optimization results saved in the `hyperparameter/hyperparameter_results_constructive/` directory and generates the following visualizations:

#### Individual parameter analysis
For each parameter, it generates plots showing its effect on the final cost:
- Scatter plots or boxplots depending on the number of unique values
- Trend lines to identify patterns
- Saved as `[param]_vs_cost.png`

#### Interactions between parameters analysis
Generates 3D visualizations and heat maps for parameter pairs:
- 3D surfaces showing the interaction
- Heat maps with cost values
- Contour plots to identify optimal regions
- Saved as `[param1]_[param2]_3d.png`

#### Correlation analysis
Generates correlation matrices between parameters and metrics:
- Identification of the most influential parameters
- Correlations between parameters and results
- Saved as `correlation_matrix.png`

#### Results dashboards
Generates a complete dashboard with the most important findings:
- Top 5 most influential parameters
- Reduced correlation matrix
- Information on the best configuration
- Saved as `dashboard.png`

#### Optimal parameter combinations
Visualizes the 4 best parameter combinations:
- Heat maps with markers for optimal values
- Saved as `top_combinations_heatmap.png`

Results are organized in directories by system:
```
hyperparameter_analysis/
├── best_parameters_summary.txt
├── test_system_2/
│   ├── dashboard.png
│   ├── correlation_matrix.png
│   ├── [param]_vs_cost.png
│   ├── [param1]_[param2]_3d.png
│   └── top_combinations_heatmap.png
├── test_system_9/
│   └── ...
└── test_system_10/
    └── ...
```

The `best_parameters_summary.txt` file contains a detailed summary of the best hyperparameters found for each system.

## Hyperparameter Optimization (hyperparameter_tuning.py)

The system includes a complete hyperparameter optimization module that allows finding the optimal configuration for the heuristic algorithm, adapting to different types of instances automatically.

### Execution Options

```bash
# To see available options
python hyperparameter_tuning.py --help

# Interactive mode
python hyperparameter_tuning.py interactive

# Grid search with specific parameters
python hyperparameter_tuning.py search --method grid --data_dir ./data --output_dir hyperparameter/hyperparameter_results_constructive

# Random search with partitioning for parallel execution
python hyperparameter_tuning.py search --method random --n_samples 30 --n_jobs 4 --actual_job 1

# Analysis of existing results without running search
python hyperparameter_tuning.py search --analyze --method grid

# Run heuristic with the best parameters found
python hyperparameter_tuning.py run data/test_system_1.json hyperparameter/hyperparameter_results_constructive/grid_best_parameters.csv
```

### Operation Modes

The script supports three main modes:

#### 1. Interactive Mode (`interactive`)

Guides the user through the selection process of:
- Configuration files to use
- Search method (grid or random)
- Specific parameters to explore
- Number of trials per configuration
- Output directory

This mode is ideal for users who are starting to explore the hyperparameter space.

#### 2. Search Mode (`search`)

Allows executing hyperparameter search processes through command line with detailed options:

**Available options:**
- `--config`: Path to a specific JSON file
- `--data_dir`: Directory with JSON files (default: ./cluster_results/representative_files)
- `--output_dir`: Directory for results (default: hyperparameter/hyperparameter_results_constructive)
- `--method`: Search method (grid/random)
- `--n_jobs`: Total number of partitions to process in parallel
- `--actual_job`: Index of the current partition (1 to n_jobs)
- `--n_trials`: Number of trials per configuration
- `--n_samples`: Number of samples for random search
- `--analyze`: Only analyze existing results without running search

The partitioning option allows running searches on multiple machines or cores to speed up the process.

#### 3. Run Mode with Optimal Parameters (`run`)

Runs the heuristic with the best parameters previously found:

**Required parameters:**
- `json_path`: JSON file with system configuration
- `params_path`: CSV file with the best parameters
- `--output_path`: Path to save results (optional)

This mode is useful for applying the best parameters found to new instances.

### Search Methods

#### Grid Search

Systematically explores all specified hyperparameter combinations:

```python
param_grid = {
    "max_iterations": [200, 500, 1000],
    "initial_temperature": [0.5, 1.0, 2.0],
    "cooling_factor": [0.9, 0.95, 0.98],
    "restart_threshold": [10, 20, 30],
    "intervals_perturbation_prob": [0.3, 0.4, 0.5],
    "vehicles_perturbation_prob": [0.2, 0.3, 0.4],
    "completeness_factor": [0.5, 1.0, 1.5],
    "window_factor": [1.0, 1.5, 2.0]
}
```

#### Random Search

Explores random samples within specified ranges:

```python
param_distributions = {
    "max_iterations": (100, 2000),
    "initial_temperature": (0.1, 5.0),
    "cooling_factor": (0.8, 0.99),
    "restart_threshold": (5, 50),
    "intervals_perturbation_prob": (0.1, 0.6),
    "vehicles_perturbation_prob": (0.1, 0.5),
    "hybrid_perturbation_prob": (0.1, 0.4),
    "completeness_factor": (0.2, 2.0),
    "window_factor": (0.5, 3.0)
}
```

### Results Analysis

The system automatically generates detailed analyses of the results:

- **Best parameters summary**: Text file with the best parameters found for each configuration
- **Parameter effect plots**: Visualizations showing the impact of each parameter on the final cost
- **Correlation analysis**: Shows which parameters have the greatest impact on metrics

Results are organized in the specified directory:
```
hyperparameter_results_constructive/
├── grid_search_results_combined.csv     # Combined results from all partitions
├── grid_best_parameters.csv             # Best parameters in CSV format
├── best_parameters_summary.txt          # Summary of best parameters in text format
├── instance_test_system_X_grid.txt      # Detailed results by instance
└── plots/                               # Directory with analysis plots
```

### Resilience and Parallelization Features

The system includes advanced features to handle large-scale searches:

- **Automatic resumption**: Detects and resumes interrupted searches
- **Work partitioning**: Divides the search space for execution on multiple machines
- **Incremental saving**: Saves results periodically to avoid losses due to interruptions
- **Automatic backup**: Creates backups of corrupted or damaged files

### Complete Usage Example

```bash
# 1. Run grid search in 4 partitions
python hyperparameter_tuning.py search --method grid --n_jobs 4 --actual_job 1 --data_dir ./data
python hyperparameter_tuning.py search --method grid --n_jobs 4 --actual_job 2 --data_dir ./data
python hyperparameter_tuning.py search --method grid --n_jobs 4 --actual_job 3 --data_dir ./data
python hyperparameter_tuning.py search --method grid --n_jobs 4 --actual_job 4 --data_dir ./data

# 2. Analyze combined results
python hyperparameter_tuning.py search --analyze --method grid

# 3. Run with the best parameters
python hyperparameter_tuning.py run data/test_system_5.json hyperparameter/hyperparameter_results_constructive/grid_best_parameters.csv
```

This flow allows efficiently exploring the hyperparameter space and applying the best results to new instances.

## Contributions

The project integrates several complementary approaches to obtain optimized solutions:

1. The heuristic provides fast, good quality solutions
2. RL generates policies that adapt to different types of instances
3. MILP refines solutions to obtain additional improvements
4. Clustering analysis allows selecting optimal parameters automatically

## Key Results

- **Cost reduction**: Up to 15-20% compared to simple policies
- **Demand satisfaction**: >95% of required energy in most instances
- **Solution time**: Seconds for the heuristic, minutes for RL+MILP
- **Scalability**: Tested with instances of up to 500+ vehicles

## Author

Tomás Acosta Bernal

## References

Li, H., Han, B., Li, G., Wang, K., Xu, J., & Khan, M. W. (2024). Decentralized collaborative optimal scheduling for EV charging stations based on multi‐agent reinforcement learning. *IET Generation, Transmission & Distribution*, *18*(6), 1172–1183. https://doi.org/10.1049/gtd2.13047

Rizopoulos, D., & Esztergár-Kiss, D. (2023). Heuristic time-dependent personal scheduling problem with electric vehicles. *Transportation (Dordrecht)*, *50*(5), 2009–2048. https://doi.org/10.1007/s11116-022-10300-0

Li, J., Xu, Y., Zhang, J., Gao, C., & Sun, H. (2025). Distributed EV scheduling in distribution networks with reserve market participation under ambiguous probability distribution. *Applied Energy*, *383*, 125269-. https://doi.org/10.1016/j.apenergy.2024.125269

Sone, S. P., Lehtomaki, J. J., Khan, Z., Umebayashi, K., & Kim, K. S. (2024). Robust EV Scheduling in Charging Stations Under Uncertain Demands and Deadlines. *IEEE Transactions on Intelligent Transportation Systems*, *25*(12), 21484–21499. https://doi.org/10.1109/TITS.2024.3466514

Ran, Y., Liao, H., Liang, H., Lu, L., & Zhong, J. (2024). Optimal Scheduling Strategies for EV Charging and Discharging in a Coupled Power–Transportation Network with V2G Scheduling and Dynamic Pricing. Energies (Basel), 17(23), 6167-. https://doi.org/10.3390/en17236167

Mao, T., Zhang, X., & Zhou, B. (2019). Intelligent Energy Management Algorithms for EV-charging Scheduling with Consideration of Multiple EV Charging Modes. Energies (Basel), 12(2), 265-. https://doi.org/10.3390/en12020265

Shohan, M. J. A., Islam, M. M., Owais, S., & Faruque, M. O. (2024). Optimal Energy Management of EVs at Workplaces and Residential Buildings Using Heuristic Graph-Search Algorithm. Energies (Basel), 17(21), 5278-. https://doi.org/10.3390/en17215278

---

This project was developed as part of a research on optimization of charging infrastructure for electric vehicles.
